<html>
    <head>
        <title>Notes: Making Impossible States Impossible by Richard Feldman - Cadel Watson</title>

        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <style>
            main {
                display: flex;
                flex-direction: column;
            }

            body {
                font-family: sans-serif;
                box-sizing: border-box;
                font-size: 16px;
                line-height: 1.5em;
            }

            article {
                width: 100%;
            }

            header > h1 {
                margin-bottom: 0.25em;
            }

            header > p {
                margin-top: 0px;
                margin-bottom: 0px;
                font-style: italic;
            }

            header {
                margin-bottom: 1em;
            }

            a {
                color: inherit;
            }

            article {
                border: 1px solid black;
                border-radius: 5px;
            }

            nav > ul {
                list-style: none;
                /* padding: 0.5rem; */
                padding-left: 0.5rem;
            }

            section {
                padding-left: 0.5rem;
                min-width: 0;
            }

            figure {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            figure img {
                max-width: 50%;
                border: 1px solid black;
            }

            figure {
                margin-bottom: 0;
            }

            figcaption h4 {
                margin-top: 0.5rem;
                font-weight: normal;
                font-style: italic;
                margin-bottom: 0.5rem;
            }

            blockquote {
                font-style: italic;
            }

            section p {
                margin: 1.5em 0;
            }

            .section-list {
                list-style: none;
                padding-left: 0;
            }

            .recent-list {
                list-style: none;
                font-style: italic;
                padding-left: 0;
            }

            .recent-header {
                font-size: inherit;
                margin-bottom: 0em;
            }

            .section-list li p {
                font-style: italic;
                margin: 0.5em 0 1.5em 0;
            }

            .footer {
                font-size: 10px;
                text-align: right;
                margin-right: 0.5em;
            }

            .book-description {
                font-style: italic;
            }

            pre {
                overflow-x: scroll;
            }

            @media (min-width: 800px) {
                main {
                    width: 60vw;
                    margin: 1rem auto;
                }

                article {
                    display: flex;
                }

                nav {
                    margin: 1rem;
                }

                section {
                    margin: 1rem;
                    flex-grow: 1;
                    padding-left: 0rem;
                }
            }
        </style>
    </head>

    <body>
        <main>
            <header>
                <h1>Cadel Watson</h1>
                <p>cadel@cadelwatson.com</p>
                <p>
                    <a href="https://github.com/kdelwat">github.com/kdelwat</a>
                </p>
            </header>

            <article>
                <section>
                    <h1>Notes: Making Impossible States Impossible by Richard Feldman</h1>

<p>_These are my notes on Richard Feldman&rsquo;s talk, <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8&amp;list=PLglJM3BYAMPH2zuz1nbKHQyeawE4SN0Cd&amp;index=11">&ldquo;Making Impossible States Impossible&rdquo;</a>. Code samples are his._</p>

<p><strong>Key idea:</strong> Instead of writing endless tests for invalid inputs and state, or adding complex code to handle edge-cases, use type systems to make representing impossible state physically impossible.</p>

<p><strong>Case study:</strong> CSS @-rules. The directives <code>@charset</code>, <code>@import</code>, and <code>@namespace</code> have to be in a very specific order, or else the stylesheet is invalid.</p>

<p>If they were represented as a list of properties, a user could include them in any order, so a naive generator which parses the list and creates CSS would create invalid output. What about sorting the list first? This adds complexity and edge cases.</p>

<p>The best solution is to make it impossible to declare an invalid stylesheet.</p>

<p>Instead of this type, which allows any number of invalid rule combinations:</p>

<pre><code>type alias Stylesheet =
  { declarations: List Declaration }
</code></pre>

<p>Use a more detailed type description:</p>

<pre><code>type alias Stylesheet =
  { charset : Maybe String
  , imports : List Import
  , namespaces: List Namespace
  , declarations: List Declaration
  }
</code></pre>

<p>The program off-loads the task of validation to the compiler, reducing the need for code to handle edge-cases. There is less need for tests, too, since a test for invalid state can&rsquo;t even compile.</p>

<p><strong>Case study:</strong> Survey app.</p>

<p>How can we extend this to the model of an application?</p>

<p>Consider a survey app that takes questions and user responses. A naive model would look like:</p>

<pre><code>type alias Model =
  { prompts : List String
  , responses : List (Maybe String)
  }
</code></pre>

<p>But this means that impossible states are possible. The user could provide a response without a corresponding question:</p>

<pre><code>{ prompts = []
, responses = [ Just &quot;Yes&quot; ]
}
</code></pre>

<p>A better alternative is the following, which means that neither prompt or response can stand alone.</p>

<pre><code>type alias Question =
  { prompt : String
  , response : Maybe String
}

type alias Model =
  { questions: List Question }
</code></pre>

<p>When dealing with multiple lists, whose elements map to each other, consider combining them into a single list with multiple fields per element.</p>

<p>If we extend the survey app to allow for moving forwards and backwards through questions, we need to model it.</p>

<p>Consider the naive approach:</p>

<pre><code>type alias History =
  { questions : List Question
  , current : Question
}
</code></pre>

<p>There are two ways to represent invalid state. There could be a current question when none exist, or a current question that doesn&rsquo;t exist in the question list.</p>

<pre><code>{ questions = []
, current = weather
}

{ first : a
  , others : [b, c]
  , current : d
}
</code></pre>

<p>To fix both issues, use a zip list:</p>

<pre><code>type alias History =
  { previous : List Question
  , current : Question
  , remaining : List Question
  }
</code></pre>

<p><strong>Case study:</strong> API upgrades</p>

<p>When exposing an API, allowing the user to rely on implementation details is a bad idea. We need to make using internal state externally impossible.</p>

<p>Say that a survey app exposes an API like this:</p>

<pre><code>back : History -&gt; History
forward: History -&gt; History
answer : String -&gt; History -&gt; History
init : Question -&gt; List Question -&gt; History
</code></pre>

<p>If a user&rsquo;s code uses something like <code>history.questions</code>, there will need to be a breaking change.</p>

<p>To make such state impossible, use a <em>single-constructor union type</em>:</p>

<pre><code>type History =
 History
   { previous : List Question
   , current : Question
   , remaining: List Question
 }
</code></pre>

<p>There is no way to read the fields from this type, although it comes with the penalty that internally we need to destructure its fields before use.</p>

<p>Don&rsquo;t expose the single constructor, just the type. Then users can&rsquo;t destructure it, but can use it as a type signature.</p>

<p>Expose accessor functions for internal fields that may be useful.</p>

<pre><code>questions : History -&gt; List Question
</code></pre>

<p><strong>Case study:</strong> Adding a status bar.</p>

<p>We want to add a status bar to the survey app.</p>

<pre><code>type alias Model =
  { status : Maybe String}
</code></pre>

<p>Then, we want to add an undo button if the status is &ldquo;Question deleted&rdquo;, which points to the question to restore.</p>

<pre><code>type alias Model =
  { status : Maybe String
  , questionToRestore : Maybe SurveyQuestion
  }
</code></pre>

<p>This model allows representing impossible state (pointing to a question, without a status).</p>

<pre><code>{ status = Nothing
, questionToRestore = Just question}
</code></pre>

<p>Use union types to replace multiple Maybes in a model - it prevents invalid combinations of valued and valueless fields, and makes relationships explicit.</p>

<pre><code>type Status
  = NoStatus
  | TextStatus String
  | DeletedStatus String Question
</code></pre>

                </section>
            </article>

            <footer></footer>
        </main>
    </body>
</html>
